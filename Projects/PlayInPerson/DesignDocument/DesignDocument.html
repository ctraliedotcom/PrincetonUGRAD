<!-- Start of StatCounter Code -->
<script type="text/javascript">
var sc_project=7309088; 
var sc_invisible=1; 
var sc_security="f655b56d"; 
</script>
<script type="text/javascript"
src="http://www.statcounter.com/counter/counter.js"></script>
<noscript><div class="statcounter"><a title="free hit counter"
href="http://statcounter.com/" target="_blank"><img class="statcounter"
src="http://c.statcounter.com/7309088/0/f655b56d/1/" alt="free hit
counter"></a></div></noscript>
<!-- End of StatCounter Code -->
<html><head><title>Design Document</title><style type="text/css">ol{margin:0;padding:0}p{margin:0}.c3{line-height:1.15;padding-top:0pt;height:11pt;text-align:left;direction:ltr;padding-bottom:0pt}.c8{line-height:1.15;padding-top:0pt;text-align:center;direction:ltr;padding-bottom:0pt}.c0{line-height:2.0;padding-top:0pt;text-align:left;direction:ltr;padding-bottom:0pt}.c6{line-height:1.15;padding-top:0pt;text-align:left;direction:ltr;padding-bottom:0pt}.c5{color:#404040;font-size:26pt;font-style:italic}.c9{width:468.0pt;background-color:#ffffff;padding:72.0pt 72.0pt 72.0pt 72.0pt}.c11{color:#404040;font-size:18pt}.c1{font-weight:bold}.c7{text-decoration:underline}.c2{font-size:14pt}.c10{text-indent:36.0pt}.c4{height:11pt}body{color:#000000;font-size:11pt;font-family:Arial}h1{padding-top:24.0pt;color:#000000;font-size:24pt;font-family:Arial;font-weight:bold;padding-bottom:6.0pt}h2{padding-top:18.0pt;color:#000000;font-size:18pt;font-family:Arial;font-weight:bold;padding-bottom:4.0pt}h3{padding-top:14.0pt;color:#000000;font-size:14pt;font-family:Arial;font-weight:bold;padding-bottom:4.0pt}h4{padding-top:12.0pt;color:#000000;font-size:12pt;font-family:Arial;font-weight:bold;padding-bottom:2.0pt}h5{padding-top:11.0pt;color:#000000;font-size:11pt;font-family:Arial;font-weight:bold;padding-bottom:2.0pt}h6{padding-top:10.0pt;color:#000000;font-size:10pt;font-family:Arial;font-weight:bold;padding-bottom:2.0pt}</style></head><body class="c9"><p class="c6"><img height="128" src="images/image00.png" width="592"></p><p class="c3"><span class="c1"></span></p><p class="c6"><span class="c5 c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c8"><span class="c1 c5">&nbsp; Design Document</span></p><p class="c3"><span class="c5 c1"></span></p><p class="c3"><span class="c5 c1"></span></p><p class="c8"><span class="c11">Chris Koscielny &bull; Chris Tralie &bull; Minqi Jiang &bull; Zane Ma</span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c1"></span></p><p class="c0"><span class="c1 c2">High-Level Architecture Overview</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The system consists of an Apache web server, a MySql database, and a Java socket server.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The web server serves the main html pages, the main user interface swf file, the swf files for each game, and a php script. Note that swf files consist of compiled Adobe Flex code. The main html page serves only to check that a compatible version of Adobe flash player is installed on a user&#39;s computer &ndash; if a compatible version isn&#39;t installed, it links the user to the main Adobe website. Otherwise, the main html loads the main interface swf and runs it in the Flash player on the user&#39;s browser (note that the main html file was automatically generated by Flashbuilder, our Flex development environment). Inside the main interface, when the user tries to register a new account, the information is sent as an http request to the php script on the web server to be processed. After the user logs in and tries to play a game, the main interface loads the swf file containing the game from the web server.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MySql database stores the user login information. When the user first registers, the php script checks to make sure the data is valid, then adds the user to a table in the database. When the user connects to the socket server and tries to login, the credentials that the user sends are compared against those in the database.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The main interface swf file creates a socket connection to the Java socket server. This server handles the messaging in the chat room (i.e. when a user sends a message to the chat room, the server forwards the message to everyone else in the room). The socket server also manages invitations and game servers. When a user creates a game, the socket server instantiates a game module and associates it with that user. When the game creator invites other users, the invitations are recorded in the game module.</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c1 c2">The Main Interface</span></p><p class="c0"><span class="c7 c2">Overview</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The main interface is divided into a number of smaller components, each responsible for specific tasks. PlayInPersonView.mxml describes the main graphical structure of the site, and PlayInPerson.as facilitates communication between all modules within the main interface (the constructor for this class is essentially the Java equivalent of a main method for the application). PIPSocket.as and the other files in the com.playinperson.pipsocket package are responsible for managing the socket connection between the Java socket server and the main interface.</span></p><p class="c0"><span class="c2">LocalAVManager.as manages the local audio and video settings (i.e. settings related to the microphone and webcam). StreamManager.as manages the peer-to-peer connection between clients in a game room. Both of these manager modules are located in the com.playinperson.client package. The com.playinperson.views packages contains 4 key modules controlling different aspects of the interface. The LoginBox module contains the logic and graphical description of the Login screen visible on the first page of the site. The ChatroomBox module contains the logic and graphical description of the chat room interface. The NewGame module contains the logic and graphical description of the interface for creating new games. The GameRoom modules contains the logic and graphical description of the game room interface (this interface contains the video chat displays and mini-chat box) &ndash; this module is also responsible for downloading and starting the game modules from the web server.</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c7 c2">com.playinperson.pipsocket</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MessageTypes.as file within this package enumerates the various types of messages that can be sent between the socket server and the main interface. For example, the client can send a REQUEST_LOGIN or REQUEST_CREATE_GAME message to the server, and the client can receive messages like SERVERMSG_GAME_CREATED and SERVERMSG_USER_JOIN_GAMEROOM from the server. There are ~30 message types.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The PIPSocketEvent.as file within this package defines the event interface between the PIPSocket class and the main interface. For example, after the user sends a message to the socket server requesting a login, the server replies with a message. The PIPSocket class fires the onLogin event to notify whoever is listening to this event (in this case, the main controller, PlayInPerson.as, is listening to all events fired by the PIPSocket). There are a variety of other events (see the file for the full list), but the params object in the PIPSocketEvent.as is a dictionary containing information associated with the event (e.g. for the onLogin event, params.success indicates whether the login attempt was successful, and params.username indicates the username that the user logged in with if it was successful).</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The PIPSocket.as file contains the logic for managing the actual socket connection with the java server. The socketConnection variable is an instance of the ActionScript Socket class which abstracts much of the low level socket functionality. The constructor of PIPSocket registers a number of event listeners with socketConnection &ndash; for example, _handleSocketData is set as an event listener for the SOCKET_DATA event. So, when socketConnection fires the SOCKET_DATA event indicating that data was received from the Java server, the _handleSocketData processes the data.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Each message sent between the main interface and the Java server consists of a JSON encoded object and a 4 byte prefix indicating the number of byte in the JSON encoded object. The _handleSocketData function is responsible for reading the socket stream and parsing the data into JSON objects. The _handleSockData function then passes each JSON object to the parseMessage function which performs a JSON decode and then takes the appropriate action for that message (usually, the appropriate action is to dispatch an event so that the main interface can handle the response). Finally, the PIPSocket.as class contains a variety of public functions like sendNewGame and sendLeaveGame which sends messages to the Java server.</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c7 c2">com.playinperson.views</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The GUIEvent.as class within this package enumerates the events that can be dispatched by the various graphical components of the main interface. For example, onRequestLogin is dispatched when the user presses the login button on the main page, and onRequestNewGame is dispatched when the user presses the NewGame button the NewGame page.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Authentication.LoginBox class contains the graphical description of the login and registration box on the main page along with its functionality. So, for example, the class contains code to dispatch the onRequestLogin event when the user presses the login button. The class also contains code to handle the registration process (e.g. there is code to check to make sure the username and email are valid and that the user input the same password twice). There is also code to send an HTTP request to the php script that handles the user registration and code to handle the response from the script (e.g. if the user specifies a username that already exists in the database, the php script will return an error and and error message will be displayed to the user). The user registration system will be described in more detail later.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The ChatroomBox and NewGame class are both straightforward classes that contain graphical descriptions of the chat room and new game menu respectively. They both also have a small amount of code to handle the functionality of these interfaces.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The GameRoom class contains the logic and graphical description of the game room interface (note that the class uses the &ldquo;code-behind&rdquo; design pattern to separate the graphical description into separate files &ndash; i.e. GameRoomV.mxml contains the graphical description and GameRoom.as contains the logic). This class also uses the files in com.playinperson.components. Specifically, the MyVideoDisplay.mxml file manages the local video display and video settings and the PeerVideoDisplay.mxml manages the video display for a peer video feed. Finally, this class also defines the main interface side of the interface between the game modules and main interface.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instances of the GameRoom class are instantiated when a user creates or joins a game, and the instances are garbage collected when the user leaves a game. On instantiation, a number of event listeners are registered (see the creationComplete function). For example, listeners are registered for events like changing the volume slider value or changing the microphone or webcam. When these events are fired, functions are called within GameRoom which forward the commands to the LocalAVManager singleton which handles the local microphone and webcam. After a GameRoom instance is created, the code that creates it can call initVideoDisplays to set the maximum number of players in the room; this function also initializes a MyVideoDisplay class to display the output of your local webcam and initializes a number of PeerVideoDisplay instances (number depending on the maximum number of players allowed in the room). After initVideoDisplays is called, the calling code should next call the loadGame which downloads the specified game module from the web server and loads it. When the game is finished loading, the gameReady function is called automatically and an initialization object is passed into the game (this object is just a dictionary containing the gameRoomId and the username of the local user). The interface between the GameRoom and the games will be described in more detail in the next section.</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c7 c2">interface between games and main interface</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Games are loaded by the GameRoom class, and in order for the GameRoom to recognize a game, the game module must implement the IGame.as interface. This interface is extremely simple &ndash; it just defines a single function: receiveData(data:Object). When the main interface receives data from the game server, it passes it to the GameRoom, which in turn, passes the data to the game via the receiveData function. In order for the game to send data to the gameserver (which will forward it to the necessary users), it must fire a GameEvent of type LOCAL_GAME_DATA_READY with the data it wants to send attached to the event. The GameRoom is listening for these events, so whenever the game fires this event, the GameRoom immediately receives it and sends it to the game server.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that the data:Object parameter of the receiveData function and the params:Object of the GameEvent are just dictionaries, each game and its optional game server must define the messaging protocol between clients and server. While each game doesn&#39;t need its own custom server to process game messages from the clients, if it doesn&#39;t define its own custom server logic, a default one is used. Game servers will be described in more detail in a later section, but the default game server simply forwards each message it receives from a user to every other user. The Poker game is the only game that we implemented with a custom server. Tic-tac-toe, Set, and Bomberman each use the default game server.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;While the client-server communication protocol is defined by the actual game, there are two standard communication messages sent from the GameRoom to the game. For example, the initialization object described at the end of the previous section is one such message. The other message is the GAME_ROOM_LEAVE message which the GameRoom sends to the game when a user leaves the game room (see the announceUserLeaveGameRoom function).</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c7 c2">StreamManager.as</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The StreamManager class handles the peer to peer connection between clients. After initialization, the connectCirrus method should be called to connect to the Cirrus peer-to-peer rendezvous service. After the cirrus connection is established, connectGameRoom can be called to establish the peer-to-peer NetGroup connection to the game room. After this connection is established, connectPeer can be called to initialize individual video/audio streams from other users in the game room.</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c2 c7">PlayInPerson.as</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The PlayInPerson.as module has a reference to all the modules in the main interface and facilitates communication between these modules. In the PlayInPerson constructor, the initSocketManager function, and in the creationComplete function, event listeners are registered for all important events that all the modules described in previous sections dispatch. Within the event handlers, the PlayInPerson class forwards the messages to the appropriate classes. For example, the PlayInPerson class has event listeners for all the messages that the PIPSocket class dispatches. So, when the PIPSocket class receives a public message from the server (i.e. a chatroom message sent by one user to everyone else in the room), the PIPSocket class dispatches a PIPSocketEvent which is passed to an event handler in the PlayInPerson class. This event handler then passes the message to the ChatRoom class which displays the message in the chatroom textbox. Similarly, when a game wants to send a message to the game server, it dispatches a message, the GameRoom receives it, then passes it on to the PlayInPerson class which calls the appropriate PIPSocket function to send the message to the server.</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c1 c2">MySql database and authentication system</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MySQL database contains one table, &ldquo;users&rdquo;, that stores the registration information for the site. The most important fields are username, email, password, and salt. Duplicate emails and duplicate usernames are not allowed. The salt field is a 20 digit hex representation of a 10 byte random salt. The password field is a 64 digit hex representation of the 32 byte output of sha-256 on the 10 byte salt appended to the plain text password.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When a user wants to register for an account, his registration information is first checked on the client side (e.g. the client checks to make sure the user entered the same password twice). If the information passes the checks, then the client sends a request to the request.php script asking for a salt. The server returns the hex of the salt, and the client re-encodes the salt into binary format before appending it to the user&#39;s password and hashing it. The client then sends the registration information and the encrypted password to the register.php script. Additional checks are performed on the server side before the information is added to the database. If the username or email is already registered, the user is notified and allowed to change his information before trying to register again. Ideally, the entire communication between the client and the register.php script should be encrypted over https because an attacker could theoretically eavesdrop and record the hashed user password. If an attacker acquires this hash, he&#39;d be able to use it to login to the main server.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When a user tries to login to the website, his client first connects to the socket server and sends the username he wants to login as. The server retrieves the corresponding salt from the database, generates a new random salt, and sends both back to the client. The client then hashes (sha-256) the password with the original salt, then takes the output, appends the new salt, hashes that, and sends the result back to the server. The server then takes the hashed password stored in the database, appends the new salt, hashes the result, then compares the output to the user&#39;s response. If they match, then the user entered the correct password. The purpose of this challenge-response protocol is to prevent the client from having to send either the un-hashed password, or the once-hashed password (i.e. the one stored in the database). If either of these were obtained (or sniffed over the network), then an attacker could login as the user.</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c1 c2">Java Socket Server</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Java socket server is responsible for managing the chat room, the invitation system, and the game server logic. ChatServer.java contains the main method for the application and the code to initialize both the Cross-domain policy server and the main server. ChatRoomMessageEncoder.java and ChatRoomMessageDecoder.java contain the code to encode and decode the messages sent between the main interface and the server (i.e. these classes just add and parse out the length header in the messages).</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The bulk of the code is contained in ChatRoomIOHandler.java. Whenever the chat server receives a message from a user, the messageReceived function is called. Before the message is fully processed, the server checks to make sure the user is logged in. If the user isn&#39;t logged in, the server expects the user to either request a salt or send login credentials; if the user tries to send another type of message before logging in, he is disconnected. After the user authenticates, if he sends a message to the server, the type field of the message is examined and the message is forwarded to another function to be processed. For example. If the user sends a request to create a game, then the message has type REQUEST_CREATE_GAME &ndash; the messageReceived function then sends the message to receiveRequestCreateGame which attempts to create a game. When the server needs to send a response back to the client, it calls a function in the ChatRoomMessage class to create a message object and then sends the message object. For example, when a user authenticates with the server successfully, the server sends a message informing the user that the login was a success. In order to create this message, the server calls the getLoginSuccessMsg function in the ChatRoomMessage class &ndash; this function returns a JSONObject with the necessary fields set.</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When a user creates a game room on the user-interface side, a corresponding GameRoom object is created on the socket server. The GameRoom object is responsible for sending chat messages and game messages between users in the room; therefore, it has a reference to every user session that&#39;s in the game room in the &ldquo;users&rdquo; HashSet. While the GameRoom class contains most of the logic for this functionality, it is actually abstract. The chat server actually creates instances of the InviteGameRoom class, a child class that also has an invite system built on top of the underlying game room (i.e. in order for a user to join InviteGameRoom, the game creator must have sent an invite to this user).</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The GameRoom class also acts as the interface between the rest of the socket server and the game server logic. The GameRoom class has a reference to a GameServer, an abstract class containing the base code and functions for a game server. Specifically, it has a receiveMessage function to receive messages from other users in the game, and it has an enterGame and leaveGame function so that the game server can be notified when other users enter and leave the game. It also has a reference to an IgameServerDispatcher that the game server logic can user to send messages to other users in the room. The GameRoom object implements IgameServerDispatcher, so when the GameRoom creates an instance of a GameServer, it passes in a reference to itself. The IgameServerDispatcher interface specifies two functions that allows the caller to either send a message to everyone else in the room, or to send a message to a specific person in the room.</span></p><p class="c0 c4"><span class="c1 c2"></span></p><p class="c0 c4"><span class="c1 c2"></span></p><p class="c0"><span class="c1 c2">Set</span></p><p class="c0"><span class="c2">The architecture of the Set game module consists of 3 ActionScript files: SetCard.as, SetGame.as, and SetCanvas.as. &nbsp;In addition, Set relies on SETview.mxml to load as a flex module under the main PlayInPerson interface. &nbsp;SetCard.as implements a card class that manifests the game cards, SetGame.as controls the logical flow of the game, handling things such as game initialization, game restarts, player deck synchronization, and event-based message passing to the server, which in turn forwards the messages to players. &nbsp;SetCanvas provides the canvas object on which the game is displayed.</span></p><p class="c0"><span class="c2">&nbsp;</span></p><p class="c0"><span class="c2">SetCard.as encapsulates properties of individual cards such as the values of a card&#39;s attributes (rank, color, shape, fill) and graphical display properties such as whether the SetCard is currently selected. The basic method that checks whether 3 cards form a Set is also implemented here. &nbsp;It was decided that SetCard should inherit from the Sprite class as positioning, drawing, and attaching event listeners to Sprite objects are all easily accomplished in ActionScript. &nbsp;By extending Sprite, SetCard objects inherit useful properties such as x,y coordinates corresponding to their position on screen, the ability to carry embedded bitmap graphics, and other highly useful display properties. &nbsp;SetCard also implements essential methods such as makeSetDeck which creates a new array representation of a shuffled deck of all 81 Set cards. &nbsp;The random shuffle aspect ofhte makeSetDeck method uses a custom pseudo-random number generator, which may be seeded by an integer value. &nbsp;Implementing a pseudo-random number generator was essential to paving the path to reproducible random shuffles, which are obviously crucial to synchronizing order that the set of cards will appear to disparate players engaged in the same Set game. &nbsp;A custom pseudo-random number generator also allowed development to sidestep usage of the ActionScript random number generator, which embarrassingly cannot be seeded.</span></p><p class="c0"><span class="c2">&nbsp;</span></p><p class="c0"><span class="c2">Deck and score synchronization was a critical issue and major challenge in designing and implementing Set. &nbsp;When a player creates a new Set game room, he or she is presented with a random shuffle of the deck. &nbsp;When a new player enters the game room, he or she should see the same shuffle, and the same set of cards in play. &nbsp;A new player should also immediately see his or her score in the game display, next to the scores of all other players in the game room. &nbsp;When one player&#39;s score increases, all other players should also see the score increase. &nbsp;This synchronization is accomplished through message passing. &nbsp;When a new player joins a game of Set, the new player &quot;greets&quot; the existing players who return the initial greeting. &nbsp;Each &quot;greeting&quot; consists of a series of message passes between clients, mediated by the PlayInPerson server. &nbsp;These initial greetings inform the new player of the names and corresponding scores of all existing players and of the random seed for the deck shuffle, the current deck index corresponding to the next card to be dealt by the deck, and the set of cards currently displayed along with their corresponding coordinate positions. &nbsp;Each game-state changing action such as successful Set discovery is broadcast to all other players in the game room, informing all other players&#39; Set instances to update. &nbsp;With such a synchronization scheme in place, it is now even possible for a player to join a game of Set mid-game.</span></p><p class="c0"><span class="c2">&nbsp;</span></p><p class="c0"><span class="c2">The game rules of Set are implemented entirely on client side code, with the server acting as a sort of message-passing intermediary among players. This client-centric design may have proved to be a wise decision given the nature of our small server (a personal computer), and the consequent benefit of reducing processing time on the server. &nbsp;ActionScript game code fits nicely into client-to-server-to-client message passing scheme as game applications in ActionScript relies heavily on message-passing to communicate events to disparate objects. &nbsp;When a player takes an action that changes the game state, an update message is sent to the server, which forwards the update to all other users in the game room. &nbsp;For example, selecting a set of 3 cards causes the 3 selected cards to be replaced by 3 new cards from the top of the deck, while incrementing the successful player&#39;s score. &nbsp;All of these changes, once they occur, must be communicated to all players. &nbsp;Message passing has proven successful to these ends.</span></p><p class="c0"><span class="c2">&nbsp;</span></p><p class="c0"><span class="c2">As the mathematical game rules of Set may seem quite convoluted for a beginner, and as the fast and clear discernment of the cards is of utmost importance to players, I decided the Set user interface had to be as clean and as simple as possible. &nbsp;The focus of the game display must be on the cards in play, which should be the central, visual element. &nbsp;As Set is an extremely visual game in which players essentially pit their pattern detection skills against each other, having a well drawn set of card graphics was essential to the game play, and hence the ultimate Set product. &nbsp;The rendering of the SetCard graphics is done through the a Set card draw method, which maps a unique portion of a large bitmap image containing a tiled rendition of all 81 Set game cards containing a specific card graphic to the corresponding SetCard object. Bitmap mapping offers a fast way to render the Set card graphics. &nbsp;Bitmap mapping proved especially appropriate given the regularity of the variation in Set cards (all possible combinations of four ternary attributes). &nbsp;The choice of a vivid color scheme was meant in further engage the player&#39;s attention, and keep the player engrossed in the Set game.</span></p><p class="c0"><span class="c2">&nbsp;</span></p><p class="c0"><span class="c2">In terms of user controls, it was decided that players would select Sets by clicking the mouse over selected Set cards. &nbsp;The motion of swiping a mouse or a finger across a track pad imitates the motion of swiping a hand to quickly secure a set in traditional Set game play.</span></p><p class="c0"><span class="c2">&nbsp;</span></p><p class="c0"><span class="c2">Preliminary testing of the Set program with friends has shown the game to be quite engrossing and entertaining. &nbsp;A notable feature that deserves development in the near future is a brief highlighting animation of the most recently selected set of 3 cards, which would allow the players who did not find the Set to better visualize which 3 cards have just been updated.</span></p><p class="c0"><span class="c2">&nbsp;</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c1 c2">Poker</span></p><p class="c0 c10"><span class="c2">The main design philosophy behind Texas Hold&rsquo;Em Poker was to keep the game rules and global state entirely on the server side, and to simply use the client side as a GUI to display parts of the state. &nbsp;I originally thought of leaving some of the game rule work to be determined by the client, but abandoned that because it would be too easy to cheat. &nbsp;In the final system, all of the game rules and the game flow takes place on the server. &nbsp;Who gets information about who&rsquo;s cards is very tightly controlled by the server. &nbsp;The game server only sends the cards out to the player who owns them (the server will send the player back-facing cards for all other players). &nbsp;In special cases (such as when a user goes all in and betting continues for everyone else), a particular user may have to turn over his/her cards and show them to everyone, in which case they are sent out to everyone. &nbsp;Cards are also overturned at the end of the round when people stay in the round all the way to see who wins. &nbsp;But otherwise, cards are kept secret to the client. &nbsp;</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c2">The main server file is PokerServer.java. &nbsp;It&rsquo;s two main responsibilities are receiving and dispatching all messages from the poker client, and dealing with game flow. &nbsp;This file stores the 6 spots (and array of Player[] objects) where people can sit down on the board. &nbsp;Each one of these spots has $5000 at it, and people can sit-stand at any of them before or during the game. &nbsp;PokerServer.java also has a hashmap called &ldquo;users&lt;String, Integer&gt;&rdquo; which stores a mapping between a user (username) and an index within the player[] array of spots on the table. &nbsp;If a user&rsquo;s index is -1, it means he/she is still standing and is an observer. &nbsp;There can be an unlimited amount of servers but a maximum of 6 players actually sitting down. &nbsp;In addition to dealing with sitting and standing (with the &ldquo;SIT&rdquo; and &ldquo;STAND&rdquo; messages, which fire the swapUserIn and swapUserOut functions, respectively), the PokerServer.java class also handles messages that a player sends requesting to fold, call, raise, or go all in. &nbsp;With all of these options, the server checks to make sure that it&rsquo;s actually the user&rsquo;s turn and that he/she has enough money to do the requested operation. &nbsp;Otherwise an error message is sent. &nbsp;I took particular care to make sure that users couldn&rsquo;t send the server invalid messages in order to cheat. &nbsp;One final thing to note about this file is two very important functions: broadcastAllPlayers() and broadcastGameStateChange(). &nbsp;These two functions send out all of the players to and the game state to every player and observer in the game. &nbsp;This isn&rsquo;t much data, so I don&rsquo;t bother keeping track of what&rsquo;s actually changed between the last time that a particular observer/player got data on the game and players; I just go ahead any send everything out to everyone every time there&rsquo;s a change (i.e. some user raised, it&rsquo;s a new player&rsquo;s turn, etc.).</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c2">The poker game logic is implemented primarily in &nbsp;PokerGame.java. &nbsp;This file has a function to deal cards to everyone in a random shuffle (dealCards()), and it has functions to determine whose turn it is next that takes into consideration if someone is out of money, has folded, or is out of the game (moveToNextPlayer(), getValidPlayerAfter()). &nbsp;It also has functions for allowing users to place bets (playerPlaceBet()). &nbsp;The most complicated function in this file is finalizeSession(), which is called to end a particular round in several different scenarios (most commonly when all 5 community cards have turned over and betting has completed over them, or when everyone but one person has folded. &nbsp;Less commonly when enough people have gone all in so that betting can no longer take place, when enough people have left the game, etc). &nbsp;finalizeSession() determines who the winner is, deals with split pots, determines if anyone has lost the game, or if only one user is left (the winner).</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c2">Poker hands are scored in the PokerHand class. &nbsp;This class accepts the array of 5 community cards and the two player cards, via the function updateHand(). &nbsp;The winner is determined at the end of each round with a comparator in the Player class that compares the score of each hand (the players are sorted by the value of their hand, as determined in the PokerHand class). &nbsp;The players are sorted with this comparator in finalizeSession() to determine the winner(s).</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c2">On the client side, the file that does most of the work is the actionscript file pokerLogic.as. &nbsp;This file handles button presses and accepts messages from the server, which it uses to update the state of what it&rsquo;s drawing to the screen. &nbsp;Most of this is pretty standard drawing code that is self-explanatory. &nbsp;The one thing I did that I consider to be creative is dealing with showing/hiding certain buttons. &nbsp;For instance, the buttons fold/call/raise/allin are only displayed when it&rsquo;s the player&rsquo;s turn, and only the allin and fold buttons are displayed if the user doesn&rsquo;t have enough money to call. &nbsp;Also, the &ldquo;ready for next round&rdquo; button is only displayed when the game state is INGAME_WAITING. &nbsp;Also note that there&rsquo;s an &ldquo;administrator menu&rdquo; that is only visible to one person, which has the options to start a game (if it hasn&rsquo;t started already) and to reset all players and the game state.</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c1 c2">Tic-tac-toe</span></p><p class="c0"><span class="c2">Tic-tac-toe was the first proof-of-concept game that we implemented and the game design was rather straightforward. </span></p><p class="c0"><span class="c2">Cell.as contains the custom Cell object which controls both the state (X O or blank) and the actual graphics element of the cell. The graphics are drawn using the Actionscript Graphic class, which does introduce some overhead, but with a game as basic as Tic-tac-toe, this is not a big issue. GameGrid.as is also a visual element that contains a collection of Cells and also implements the game cross-hairs that go between cells. GameGrid also contains display options for the display to correspond with different game states (ex. blurred for waiting-for-opponent state and unblurred for the players turn). TTTGame.as houses all of the game logic and the visual display elements, namely the GameGrid (with the associate cells). At game initialization, all cells in the game are given individual mouse event listeners. At each turn, the game waits on an appropriate mouse-click event on an unselected cell. Depending on the game state (X-turn or O-turn), the clicked cell is designated either X or O and the click-listener is removed from the cell. After each turn the TTTGame checks the GameGrid to determine if any winners have been decided. If not, play resumes with a change in game state (X-turn goes to O-turn). In the event of a winner being detected, the entire GameGrid is frozen and the winners/losers are announced. A restart-game option is presented, and if both players agree to restart the game, then all of the cells in the GameGrid are reset, and one player is randomly assigned to go first. &nbsp;TTTView is the MXMXL visual implementation of TTTGame, using the &quot;code-behind&quot; scheme. &nbsp;</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c1 c2">Bomberman</span></p><p class="c0"><span class="c2">Bomberman was implemented in a object-oriented manner. Bomb.as defines custom Bomb objects that embeds the image of the bomb as a BitmapData data-type, which is essentially a matrix grid of colors to be displayed at each pixel. The Bomb object contains a special BombTimer, which is used to trigger a bomb explosion after a set amount of time. Also the Bomb data type defines the explosion size, and the deployer of the bomb. Bomber.as contains important features of individual bombers including: 1) a unique ID and color for the bomber, which is set to the player&#39;s username, 2) game stats (score, player speed, bomb size, etc.) 3) player state (dead, alive, invincible). BombField.as contains the background grid display that is not redrawn during animations because the grid is stationary. All visual game objects - bombs, bombers, explosions - are drawn on top of the BombField. GameDisplay.as contains a container for the BombField, objects on the BombField, the score label along the right-side of the game, and the background display of the game that is the same color as the unique player color. </span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c2">Bomberman.as houses the game logic and multiplayer messaging system. It will be discussed in sections, according to key functions within the game. It is important to note that the primary data structure of the Bomberman class is the gameItems Array, which keeps track of all Bombs and Bombers in the game. </span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c2">Player movement. Bomberman controls player movement by utilizing keyboard event listeners that register when specific keys are pressed. Players are controlled by the arrow keys, and the space bar drops bombs (or revives dead players). The game does not move a bomber every time an arrow keyboard event is received because different clients&#39; operating systems will transmit keyboard events at different rates. Instead, when a first arrow keyboard event is received, a timer is initiated that moves the bomber in the correct direction at a fixed rate until the arrow key is released. This ensures equal movement rate for all players. Another issue is that grid intersections and corners are difficult to navigate unless a corner-rounding system is implemented. The Bomberman game-logic auto-navigates players around corners when they are only a few pixels short of being able to go around the corner. </span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c2">Bomb handling. Bombs are dropped when a player presses the space bar. To prevent overlapping bombs, bombs are automatically dropped at the nearest &quot;neat&quot; spot. &quot;Neat&quot; spots are in the exact center of an intersection or not overlapping with any part of the intersection. Additionally bombs can only be dropped in unoccupied spots. The BombTimer is started immediately after deployment and triggers the bomb explosion. The explosion animation is drawn frame-by-frame and controlled by a separate explosion timer. Concurrently, collision detection around the site of the exploding bomb is performed. The list of gameItems is checked to detect any bombs or bombers within the explosion radius. If a bomb is detected, then it is detonated. If a player is detected, then the player is killed, and the score of the bomb owner is altered accordingly.</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c2">Player death. When a bomber is killed, it is removed from the gameItems list to prevent unnecessary redrawing. All keyboard event listeners are removed and a flashing death animation is undertaken. At this point, a special spacebar keyboard listener is added so that the bomber can be revived. If the bomber is revived, the original keyboard listeners are re-added, and game play resumes. </span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c2">Messaging system. A series of notification-response messages are first sent after the creation of a game instance so that other game instances can add the new game&#39;s bomber to their BombField, and then the new game instance can add the other games&#39; bombers to its own BombField. Messages containing the coordinates and unique ID of a player are sent whenever a bomber moves or a bomber dispatches a bomb. Further messaging reports synchronizes bomber deaths and score updates. Messages also handle the case where a bomber leaves during the middle of the game. This flexible messaging system allows for users to dynamically join or leave a game at any time during the game.</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c0"><span class="c2">Future design improvement. Once we upgrade the servers for our website, the game should be redesigned to a server-client model in which the server-side code executes all the game logic in one module. This would reduce cheating and synchronization issues. The only major issue is possibly a reduction in game speed, but this can be largely overcome with a faster server and increased bandwidth. &nbsp;</span></p><p class="c0 c4"><span class="c2"></span></p><p class="c3"><span></span></p></body></html>